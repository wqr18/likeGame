<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 æ—¶ç©ºç²’å­é‡ç»„</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@900&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            overflow: hidden;
            font-family: 'Montserrat', sans-serif;
            color: white;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€UIå±‚ï¼Œä¸å½±å“ç”»å¸ƒäº¤äº’ */
            z-index: 10;
        }

        .countdown-text {
            font-size: 1.2rem;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        #timer {
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
        }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'Montserrat', sans-serif;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            border-radius: 30px;
        }

        button:hover {
            background: white;
            color: black;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        /* æç¤ºè¯­ */
        #hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: rgba(255,255,255,0.3);
            pointer-events: none;
            opacity: 1;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>

    <div id="hint">ç§»åŠ¨é¼ æ ‡ æ‰°åŠ¨æ—¶å…‰</div>

    <div id="ui-layer">
        <div class="countdown-text">è·ç¦» 2026 è¿˜æœ‰</div>
        <div id="timer">00:00:00</div>
    </div>

    <div class="controls">
        <button onclick="triggerTransition()">ğŸš€ å¯åŠ¨è·¨å¹´è·ƒè¿</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const timerElement = document.getElementById('timer');
        const hintElement = document.getElementById('hint');

        let particles = [];
        let width, height;
        let mouse = { x: null, y: null, radius: 100 };
        let currentText = "2025";
        let isExploded = false;
        let animationId;

        // åˆå§‹åŒ–ç”»å¸ƒ
        function initCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // ç²’å­ç±»
        class Particle {
            constructor(x, y) {
                this.x = Math.random() * width; // åˆå§‹éšæœºä½ç½®
                this.y = Math.random() * height;
                this.targetX = x;
                this.targetY = y;
                this.size = Math.random() * 2 + 1;
                // é¢œè‰²å¯ä»¥æ˜¯ç™½è‰²ï¼Œæˆ–è€…å¸¦ä¸€ç‚¹ç‚¹è“/é‡‘
                const colors = ['#ffffff', '#e0e0e0', '#87CEFA', '#FFD700'];
                this.color = colors[Math.floor(Math.random() * colors.length)];
                
                this.density = Math.random() * 30 + 1;
                this.friction = 0.95; // æ‘©æ“¦åŠ›ï¼Œç”¨äºå½’ä½
                this.ease = 0.05; // ç§»åŠ¨å¹³æ»‘åº¦
                this.vx = 0;
                this.vy = 0;
            }

            update() {
                // è®¡ç®—ä¸é¼ æ ‡çš„è·ç¦»
                let dx = mouse.x - this.x;
                let dy = mouse.y - this.y;
                let distance = Math.sqrt(dx*dx + dy*dy);
                let forceDirectionX = dx / distance;
                let forceDirectionY = dy / distance;
                let maxDistance = mouse.radius;
                
                // é¼ æ ‡æ–¥åŠ›è®¡ç®—
                let force = (maxDistance - distance) / maxDistance;
                let directionX = forceDirectionX * force * this.density;
                let directionY = forceDirectionY * force * this.density;

                if (distance < mouse.radius) {
                    // å¦‚æœé¼ æ ‡é è¿‘ï¼Œç²’å­è¢«æ¨å¼€
                    this.vx -= directionX;
                    this.vy -= directionY;
                } else {
                    // å¦‚æœé¼ æ ‡è¿œç¦»ï¼Œç²’å­å›åˆ°ç›®æ ‡ä½ç½®
                    if (this.x !== this.targetX) {
                        let dx = this.x - this.targetX;
                        this.vx -= dx * this.ease; // å¼¹ç°§æ•ˆæœ
                    }
                    if (this.y !== this.targetY) {
                        let dy = this.y - this.targetY;
                        this.vy -= dy * this.ease;
                    }
                }

                this.vx *= this.friction;
                this.vy *= this.friction;

                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fill();
            }
            
            // æ›´æ–°ç›®æ ‡ä½ç½®ï¼ˆç”¨äºæ–‡å­—å˜æ¢ï¼‰
            newTarget(x, y) {
                this.targetX = x;
                this.targetY = y;
                // å˜æ¢æ—¶ç»™ä¸€ä¸ªéšæœºçˆ†å‘åŠ›
                this.vx = (Math.random() - 0.5) * 50; 
                this.vy = (Math.random() - 0.5) * 50;
            }
        }

        // æ ¸å¿ƒï¼šå°†æ–‡å­—è½¬åŒ–ä¸ºç²’å­åæ ‡
        function createParticlesFromText(text) {
            ctx.clearRect(0,0, width, height);
            
            // ä¸´æ—¶ç»˜åˆ¶æ–‡å­—æ¥è·å–åƒç´ æ•°æ®
            let fontSize = Math.min(width / 5, 250); // è‡ªé€‚åº”å­—ä½“å¤§å°
            ctx.font = `900 ${fontSize}px Montserrat, Arial`;
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            // è·å–åƒç´ æ•°æ®
            // ä¸ºäº†æ€§èƒ½ï¼Œåªæ‰«æéƒ¨åˆ†åŒºåŸŸæˆ–é™ä½é‡‡æ ·ç‡
            const textCoordinates = ctx.getImageData(0, 0, width, height);
            const buffer32 = new Uint32Array(textCoordinates.data.buffer);
            
            let newCoordinates = [];
            // é‡‡æ ·é—´éš”ï¼Œè¶Šå°ç²’å­è¶Šå¯†é›†ï¼Œæ€§èƒ½æ¶ˆè€—è¶Šå¤§
            let gap = 5; 
            if(width < 768) gap = 3; // æ‰‹æœºç«¯ç¨å¾®å¯†é›†ç‚¹å› ä¸ºå­—ä½“å°

            for (let y = 0; y < height; y += gap) {
                for (let x = 0; x < width; x += gap) {
                    if (buffer32[y * width + x] & 0xff000000) { // æ£€æŸ¥æ˜¯å¦æœ‰åƒç´ ï¼ˆéé€æ˜ï¼‰
                        newCoordinates.push({x, y});
                    }
                }
            }

            // è°ƒæ•´ç²’å­æ•°é‡
            if (particles.length < newCoordinates.length) {
                // å¦‚æœç°æœ‰ç²’å­ä¸å¤Ÿï¼Œè¡¥å……æ–°ç²’å­
                let diff = newCoordinates.length - particles.length;
                for (let i = 0; i < diff; i++) {
                    particles.push(new Particle(newCoordinates[i].x, newCoordinates[i].y));
                }
            } else {
                // å¦‚æœç°æœ‰ç²’å­å¤ªå¤šï¼Œåˆ é™¤å¤šä½™çš„
                particles.splice(newCoordinates.length);
            }

            // æ›´æ–°ç°æœ‰ç²’å­çš„ç›®æ ‡
            for (let i = 0; i < newCoordinates.length; i++) {
                particles[i].newTarget(newCoordinates[i].x, newCoordinates[i].y);
            }
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; // æ‹–å°¾æ•ˆæœï¼ŒèƒŒæ™¯ä¸æ˜¯å®Œå…¨æ¸…é™¤
            ctx.fillRect(0, 0, width, height);

            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            animationId = requestAnimationFrame(animate);
        }

        // äº¤äº’äº‹ä»¶
        window.addEventListener('mousemove', (e) => {
            mouse.x = e.x;
            mouse.y = e.y;
            hintElement.style.opacity = 0; // ä¸€æ—¦åŠ¨äº†é¼ æ ‡ï¼Œæç¤ºæ¶ˆå¤±
        });
        
        window.addEventListener('touchmove', (e) => {
             mouse.x = e.touches[0].clientX;
             mouse.y = e.touches[0].clientY;
             hintElement.style.opacity = 0;
        });
        
        // é¼ æ ‡ç§»å‡ºç”»å¸ƒå¤ä½
        window.addEventListener('mouseout', () => {
            mouse.x = undefined;
            mouse.y = undefined;
        });

        window.addEventListener('resize', () => {
            initCanvas();
            createParticlesFromText(currentText);
        });

        // --- é€»è¾‘æ§åˆ¶ ---
        
        initCanvas();
        createParticlesFromText("2025"); // åˆå§‹æ–‡å­—
        animate();

        // å€’è®¡æ—¶é€»è¾‘
        let targetDate = new Date("January 1, 2026 00:00:00").getTime();
        
        // æ¼”ç¤º/è§¦å‘å‡½æ•°
        window.triggerTransition = function() {
            if(isExploded) return;
            isExploded = true;
            
            // 1. å€’è®¡æ—¶æ¸…é›¶
            targetDate = new Date().getTime(); 
            timerElement.innerText = "00:00:00";
            
            // 2. çˆ†ç‚¸æ•ˆæœï¼šé€šè¿‡æ”¹å˜æ‰€æœ‰ç²’å­çš„vx/vyå®ç°
            particles.forEach(p => {
                p.vx = (Math.random() - 0.5) * 100;
                p.vy = (Math.random() - 0.5) * 100;
            });

            // 3. å»¶è¿Ÿä¸€ç‚¹ç‚¹åï¼Œé‡ç»„ä¸º2026
            setTimeout(() => {
                currentText = "2026";
                createParticlesFromText("2026");
                
                // å†è¿‡å‡ ç§’ï¼Œæ˜¾ç¤º Happy New Year
                setTimeout(() => {
                   currentText = "HAPPY NEW YEAR";
                   createParticlesFromText("HAPPY\nNEW YEAR"); // ç®€å•å¤„ç†æ¢è¡Œé€šå¸¸éœ€è¦å¤æ‚é€»è¾‘ï¼Œè¿™é‡Œç®€åŒ–
                   // å®é™…ä¸Šcanvas fillTextä¸æ”¯æŒè‡ªåŠ¨æ¢è¡Œï¼Œè¿™é‡Œä¸ºäº†ç®€å•ï¼Œæˆ‘ä»¬åˆ‡æ¢æ˜¾ç¤ºå†…å®¹
                   createParticlesFromText("2026"); // ä¿æŒ2026ä¸åŠ¨æˆ–è€…æ˜¾ç¤ºæ–°å¹´
                   
                   // ç®€å•çš„çƒŸèŠ±èƒŒæ™¯ä½œä¸ºç‚¹ç¼€ï¼ˆå¯é€‰ï¼Œè¿™é‡Œç”¨èƒŒæ™¯è‰²é—ªçƒä»£æ›¿å¤æ‚çƒŸèŠ±ä»¥ä¿æŒæç®€ï¼‰
                   document.body.style.backgroundColor = "#1a0033";
                   setTimeout(()=> document.body.style.backgroundColor = "#050505", 500);
                }, 3000);
                
            }, 800);
        };

        setInterval(() => {
            if(isExploded) return;
            
            const now = new Date().getTime();
            const distance = targetDate - now;

            if (distance < 0) {
                triggerTransition();
                return;
            }

            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            
            timerElement.innerText = 
                `${hours.toString().padStart(2,'0')}:${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
        }, 1000);

    </script>
</body>
</html>